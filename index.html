<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ultimate Classic Roblox Clone</title>
<style>
body {margin:0; font-family:Arial; background:#b3e0ff; overflow:hidden;}
canvas {display:block; background:#87ceeb;}
#ui {position:absolute; top:10px; left:10px; background:rgba(255,255,255,0.9); padding:10px; border:2px solid #000;}
#chat {position:absolute; bottom:0; left:10px; width:400px; max-height:250px; overflow-y:auto; background:rgba(255,255,255,0.9); border:2px solid #000; padding:5px;}
#chatInput {width:380px; padding:5px;}
button {font-size:14px; padding:3px 6px; margin:2px; cursor:pointer;}
</style>
</head>
<body>

<div id="ui">
Username: <span id="usernameDisplay">Player1</span><br>
Robux: <span id="robuxDisplay">100</span> | Tickets: <span id="tixDisplay">500</span><br>
<button onclick="switchMap('obby')">Obby Map</button>
<button onclick="switchMap('hangout')">Hangout Map</button>
<button onclick="switchMap('brickworld')">Brick World Map</button>
<button onclick="buyItem('hat',50)">Buy Hat (50 Tix)</button>
<button onclick="buyItem('shirt',100)">Buy Shirt (100 Tix)</button>
<button onclick="buyItem('pants',75)">Buy Pants (75 Tix)</button>
<button onclick="collectCoins()">Collect Coin (+10 Tix)</button>
</div>

<canvas id="gameCanvas" width="1400" height="700"></canvas>

<div id="chat">
  <div id="chatMessages"></div>
  <input type="text" id="chatInput" placeholder="Type message and hit Enter">
</div>

<script>
// CANVAS SETUP
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// PLAYER DEFINITION
const player = {
    x: 50, y: 600, width: 30, height: 50, color: '#ffcc00',
    speed: 4, jumpPower: 12, vy: 0, onGround: false,
    username: 'Player1', robux: 100, tix: 500,
    inventory: []
};

// PLAYERS ARRAY
const players = [player];
for(let i=1; i<=50; i++){
    players.push({
        x: 50 + i*25, y: 600, width:30, height:50,
        color: '#' + Math.floor(Math.random()*16777215).toString(16),
        vy:0, onGround:false, speed:3, jumpPower:10,
        username:'Player'+(i+1), robux:0, tix:0, inventory:[]
    });
}

// INPUT
const keys = {};
document.addEventListener('keydown', e => keys[e.key] = true);
document.addEventListener('keyup', e => keys[e.key] = false);

// CHAT
const chatInput = document.getElementById('chatInput');
const chatMessages = document.getElementById('chatMessages');
chatInput.addEventListener('keydown', e=>{
    if(e.key==='Enter' && chatInput.value.trim()!==''){
        const msg = document.createElement('div');
        msg.textContent = `${player.username}: ${chatInput.value}`;
        chatMessages.appendChild(msg);
        chatInput.value='';
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
});

// CURRENCY FUNCTIONS
function updateCurrencyUI(){
    document.getElementById('robuxDisplay').textContent = player.robux;
    document.getElementById('tixDisplay').textContent = player.tix;
}
function earnCurrency(type, amount){
    if(type==='robux') player.robux += amount;
    if(type==='tix') player.tix += amount;
    updateCurrencyUI();
}
function spendCurrency(type, amount){
    if(type==='robux' && player.robux>=amount){ player.robux-=amount; updateCurrencyUI(); return true; }
    if(type==='tix' && player.tix>=amount){ player.tix-=amount; updateCurrencyUI(); return true; }
    return false;
}

// SHOP
function buyItem(item, price){
    if(spendCurrency('tix', price)){
        player.inventory.push(item);
        alert('You bought a '+item+'!');
    } else {
        alert('Not enough Tickets!');
    }
}

// COLLECTIBLE
function collectCoins(){
    earnCurrency('tix', 10);
    alert('You collected a coin! +10 Tix');
}

// MAPS
const maps = {
    obby: [],
    hangout: [],
    brickworld: []
};

// GENERATE HUGE MAPS
function generateMaps(){
    // OBBY: 200 blocks + wedges + cylinders
    for(let i=0;i<200;i++){
        maps.obby.push({type:'block', x:i*60, y:600 - Math.floor(Math.random()*400), width:50, height:20, color:'#'+Math.floor(Math.random()*16777215).toString(16)});
        if(i%5===0) maps.obby.push({type:'wedge', x:i*60+25, y:500 - Math.floor(Math.random()*200), width:50, height:25, color:'#'+Math.floor(Math.random()*16777215).toString(16)});
        if(i%7===0) maps.obby.push({type:'cylinder', x:i*60+30, y:550, width:30, height:30, color:'#'+Math.floor(Math.random()*16777215).toString(16)});
    }
    // HANGOUT: 150 blocks + decorations
    for(let i=0;i<150;i++){
        maps.hangout.push({type:'block', x:i*60, y:600 - Math.floor(Math.random()*200), width:50, height:20, color:'#'+Math.floor(Math.random()*16777215).toString(16)});
        if(i%3===0) maps.hangout.push({type:'wedge', x:i*60+20, y:500 - Math.floor(Math.random()*100), width:50, height:25, color:'#'+Math.floor(Math.random()*16777215).toString(16)});
    }
    // BRICKWORLD: 250 blocks + wedges + cylinders
    for(let i=0;i<250;i++){
        maps.brickworld.push({type:'block', x:i*50, y:600 - Math.floor(Math.random()*300), width:50, height:20, color:'#'+Math.floor(Math.random()*16777215).toString(16)});
        if(i%4===0) maps.brickworld.push({type:'wedge', x:i*50+25, y:500 - Math.floor(Math.random()*150), width:50, height:25, color:'#'+Math.floor(Math.random()*16777215).toString(16)});
        if(i%6===0) maps.brickworld.push({type:'cylinder', x:i*50+20, y:550, width:30, height:30, color:'#'+Math.floor(Math.random()*16777215).toString(16)});
    }
}

generateMaps();

// CURRENT MAP
let currentMap='obby';
let blocks = [...maps[currentMap]];
function switchMap(name){ 
    if(maps[name]){
        currentMap=name; blocks=[...maps[name]]; 
        player.x=50; player.y=600; 
    } 
}

// PHYSICS
function updatePlayer(p){
    if(p===player){
        if(keys['a']||keys['ArrowLeft']) p.x -= p.speed;
        if(keys['d']||keys['ArrowRight']) p.x += p.speed;
        if((keys['w']||keys['ArrowUp']||keys[' ']) && p.onGround){ p.vy=-p.jumpPower; p.onGround=false; }
    }
    p.vy += 0.5; // gravity
    p.y += p.vy;
    p.onGround = false;
    for(const b of blocks){
        const bw = b.width || 50, bh = b.height || 20;
        if(p.x + p.width > b.x && p.x < b.x+bw && p.y+p.height > b.y && p.y < b.y+bh){
            if(p.vy>0){ p.y=b.y-p.height; p.vy=0; p.onGround=true; }
        }
    }
}

// DRAWING
function drawBlock(b){
    ctx.fillStyle = b.color;
    if(b.type==='block'){
        ctx.fillRect(b.x,b.y,b.width,b.height);
        for(let i=0;i<b.width;i+=10){ for(let j=0;j<b.height;j+=10){ ctx.fillStyle='#fff'; ctx.fillRect(b.x+i,b.y+j,4,4); } }
    } else if(b.type==='wedge'){
        ctx.beginPath(); ctx.moveTo(b.x,b.y+b.height); ctx.lineTo(b.x+b.width,b.y+b.height); ctx.lineTo(b.x,b.y); ctx.closePath(); ctx.fill();
    } else if(b.type==='cylinder'){
        ctx.beginPath(); ctx.ellipse(b.x+b.width/2, b.y+b.height/2, b.width/2, b.height/2, 0, 0, Math.PI*2); ctx.fill();
    }
}

function drawPlayer(p){ ctx.fillStyle=p.color; ctx.fillRect(p.x,p.y,p.width,p.height); ctx.fillStyle='#000'; ctx.font="14px Arial"; ctx.fillText(p.username, p.x, p.y-5); }

// MAIN LOOP
function loop(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(const p of players) updatePlayer(p);
    for(const b of blocks) drawBlock(b);
    for(const p of players) drawPlayer(p);
    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
